<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.2.335">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>UVic Spring School 2023 - Parallelizing iterative additive Schwarz method</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1.6em;
  vertical-align: middle;
}
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { color: #008000; } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { color: #008000; font-weight: bold; } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<link href="..//img/sfu_favicon.png" rel="icon" type="image/png">
<script src="../site_libs/quarto-html/quarto.js"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit"
  }
}</script>

  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<link rel="stylesheet" href="../styles.css">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg navbar-dark ">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container">
    <a href="../index.html" class="navbar-brand navbar-brand-logo">
    <img src="../img/sfudrac_logo.png" alt="SFU &amp; DRAC logos" class="navbar-logo">
    </a>
  </div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../bash/index.html">
 <span class="menu-text">Bash</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../hpc/index.html">
 <span class="menu-text">HPC</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../r_intro/index.html">
 <span class="menu-text">Intro R</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../r_parallel/index.html">
 <span class="menu-text">Parallel R</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../julia/index.html">
 <span class="menu-text">Parallel Julia</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../ml/index.html">
 <span class="menu-text">PyTorch</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../scivis/index.html">
 <span class="menu-text">ParaView</span></a>
  </li>  
</ul>
              <div class="quarto-toggle-container">
                  <a href="" class="quarto-reader-toggle nav-link" onclick="window.quartoToggleReader(); return false;" title="Toggle reader mode">
  <div class="quarto-reader-toggle-btn">
  <i class="bi"></i>
  </div>
</a>
              </div>
              <div id="quarto-search" class="" title="Search"></div>
          </div> <!-- /navcollapse -->
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title"><em>On this page:</em></h2>
   
  <ul>
  <li><a href="#serial-additive-schwarz-method-with-explicit-matrices" id="toc-serial-additive-schwarz-method-with-explicit-matrices" class="nav-link active" data-scroll-target="#serial-additive-schwarz-method-with-explicit-matrices">Serial additive Schwarz method with explicit matrices</a></li>
  <li><a href="#serial-additive-schwarz-method-with-structures" id="toc-serial-additive-schwarz-method-with-structures" class="nav-link" data-scroll-target="#serial-additive-schwarz-method-with-structures">Serial additive Schwarz method with structures</a></li>
  <li><a href="#parallel-additive-schwarz-method" id="toc-parallel-additive-schwarz-method" class="nav-link" data-scroll-target="#parallel-additive-schwarz-method">Parallel additive Schwarz method</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content page-columns page-full" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Parallelizing iterative additive Schwarz method</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  

</header>

<div class="page-columns page-full"><p>In this section we will implement the iterative additive Schwarz method (ASM) <a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a> in Julia, starting with a serial version. We will then parallelize it with DistributedArrays.jl.</p><div class="no-row-height column-margin column-container"><li id="fn1"><p><sup>1</sup>&nbsp;“An Introduction to Domain Decomposition Methods” by Victorita Dolean, Pierre Jolivet, and Frédéric Nataf</p></li></div></div>
<p>We will be solving the 1D Poisson problem</p>
<p></p>
<p>Discretizing this equation on a uniform grid of <span class="math inline">\(m\)</span> points, we have</p>
<p></p>
<p>or in matrix notation <span class="math inline">\(AU=F\)</span>, where</p>
<p></p>
<p>Let’s break our grid into two domains <span class="math inline">\(\Omega=\Omega_1\bigcup\Omega_2\)</span>, where we are looking for the solution</p>
<p></p>
<p>In matrix notation the solution can be written as <span class="math inline">\(U_i=R_iU\)</span>, where the <strong>restriction operator</strong> <span class="math inline">\(R_1\)</span> is a <span class="math inline">\(m_s\times m\)</span> matrix consisting of two parts of sizes <span class="math inline">\(m_s\times m_s\)</span> and <span class="math inline">\(m_s\times(m-m_s)\)</span>, and <span class="math inline">\(R_2\)</span> is a <span class="math inline">\((m-m_s)\times m\)</span> matrix consisting of two parts of sizes <span class="math inline">\((m-m_s)\times m_s\)</span> and <span class="math inline">\((m-m_s)\times(m-m_s)\)</span>, respectively:</p>
<p></p>
<div class="page-columns page-full"><p>The iterative additive Schwarz method (eq. 1.30 of <a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a>) lets you compute the next iteration of the solution as</p><div class="no-row-height column-margin column-container"><li id="fn2"><p><sup>2</sup>&nbsp;“An Introduction to Domain Decomposition Methods” by Victorita Dolean, Pierre Jolivet, and Frédéric Nataf</p></li></div></div>
<p></p>
<p>where the matrix</p>
<p></p>
<p>is called the ASM preconditioner.</p>
<section id="serial-additive-schwarz-method-with-explicit-matrices" class="level3">
<h3 class="anchored" data-anchor-id="serial-additive-schwarz-method-with-explicit-matrices">Serial additive Schwarz method with explicit matrices</h3>
<p>Let’s generalize our computation to three 1D domains. For now, we are writing the serial code, so all arrays are local. Also in this first code, we will define matrices explicitly, even though <span class="math inline">\(A\)</span> is sparse, and <span class="math inline">\(R_i\)</span> are Boolean matrices. All these shortcomings will be corrected in the parallel code.</p>
<p>For matrix inversion <span class="math inline">\((R_iAT_i^T)^{-1}\)</span> we will use Julia’s builtin <code>inv()</code> function, but presumably for larger calculations you might want to replace this with your own (more efficient?) code.</p>
<!-- # 1. replace some matrices to Boolean or sparse -->
<!-- # 1. practical computing of inv() -->
<!-- # 1. parallelize -->
<p>For the right-hand side <span class="math inline">\(F\)</span>, we’ll use a constant piece in the middle, mimicking a uniform bar with empty spaces on each end.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode jl code-with-copy"><code class="sourceCode julia"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>m <span class="op">=</span> <span class="fl">21</span>               <span class="co"># total number of points</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>N <span class="op">=</span> <span class="fl">3</span>                <span class="co"># number of domains</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>ms <span class="op">=</span> <span class="fu">zeros</span>(<span class="dt">Int</span>, N)   <span class="co"># number of points in each domain</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>ms[<span class="fl">1</span><span class="op">:</span><span class="fl">2</span>] <span class="op">=</span> [<span class="fl">7</span>,<span class="fl">7</span>]      <span class="co"># number of points in the first two domains, respectively</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>ms[<span class="fl">3</span>] <span class="op">=</span> m <span class="op">-</span> <span class="fu">sum</span>(ms)</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>h <span class="op">=</span> <span class="fl">1.0</span> <span class="op">/</span> (m<span class="op">-</span><span class="fl">1</span>)      <span class="co"># grid spacing</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>U <span class="op">=</span> <span class="fu">zeros</span>(<span class="dt">Float64</span>, m, <span class="fl">1</span>);   <span class="co"># 0th iteration</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>F <span class="op">=</span> <span class="fu">zeros</span>(<span class="dt">Float64</span>, m, <span class="fl">1</span>);   <span class="co"># RHS</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>F[<span class="fu">trunc</span>(<span class="dt">Int</span>,m<span class="op">/</span><span class="fl">2</span>)<span class="op">-</span><span class="fl">3</span><span class="op">:</span><span class="fu">trunc</span>(<span class="dt">Int</span>,m<span class="op">/</span><span class="fl">2</span>)<span class="op">+</span><span class="fl">3</span>] <span class="op">.=</span> h<span class="op">^</span><span class="fl">2</span> <span class="op">*</span> <span class="fl">1.0</span>;</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>A <span class="op">=</span> <span class="fu">zeros</span>(<span class="dt">Float64</span>, m, m);</span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>A[<span class="fl">1</span>,<span class="fl">1</span>], A[m,m] <span class="op">=</span> <span class="fl">1</span>, <span class="fl">1</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="fl">2</span><span class="op">:</span>m<span class="op">-</span><span class="fl">1</span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>    A[i, i<span class="op">-</span><span class="fl">1</span>] <span class="op">=</span> <span class="op">-</span><span class="fl">1</span></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>    A[i,i] <span class="op">=</span> <span class="fl">2</span></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>    A[i, i<span class="op">+</span><span class="fl">1</span>] <span class="op">=</span> <span class="op">-</span><span class="fl">1</span></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a>R1 <span class="op">=</span> <span class="fu">zeros</span>(<span class="dt">Int32</span>, ms[<span class="fl">1</span>], m);</span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> j <span class="kw">in</span> <span class="fl">1</span><span class="op">:</span>ms[<span class="fl">1</span>]</span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a>    R1[j,j] <span class="op">=</span> <span class="fl">1</span></span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a>R2 <span class="op">=</span> <span class="fu">zeros</span>(<span class="dt">Int32</span>, ms[<span class="fl">2</span>], m);</span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> j <span class="kw">in</span> <span class="fl">1</span><span class="op">:</span>ms[<span class="fl">2</span>]</span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a>    R2[j,ms[<span class="fl">1</span>]<span class="op">+</span>j] <span class="op">=</span> <span class="fl">1</span></span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-31"><a href="#cb1-31" aria-hidden="true" tabindex="-1"></a>R3 <span class="op">=</span> <span class="fu">zeros</span>(<span class="dt">Int32</span>, ms[<span class="fl">3</span>], m);</span>
<span id="cb1-32"><a href="#cb1-32" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> j <span class="kw">in</span> <span class="fl">1</span><span class="op">:</span>ms[<span class="fl">3</span>]</span>
<span id="cb1-33"><a href="#cb1-33" aria-hidden="true" tabindex="-1"></a>    R3[j,ms[<span class="fl">1</span>]<span class="op">+</span>ms[<span class="fl">2</span>]<span class="op">+</span>j] <span class="op">=</span> <span class="fl">1</span></span>
<span id="cb1-34"><a href="#cb1-34" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span>
<span id="cb1-35"><a href="#cb1-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-36"><a href="#cb1-36" aria-hidden="true" tabindex="-1"></a><span class="co"># compute three terms in the ASM preconditioner</span></span>
<span id="cb1-37"><a href="#cb1-37" aria-hidden="true" tabindex="-1"></a>M <span class="op">=</span> <span class="fu">transpose</span>(R1) <span class="op">*</span> <span class="fu">inv</span>(<span class="fu">R1*A*transpose</span>(R1)) <span class="op">*</span> R1;</span>
<span id="cb1-38"><a href="#cb1-38" aria-hidden="true" tabindex="-1"></a>M <span class="op">+=</span> <span class="fu">transpose</span>(R2) <span class="op">*</span> <span class="fu">inv</span>(<span class="fu">R2*A*transpose</span>(R2)) <span class="op">*</span> R2;</span>
<span id="cb1-39"><a href="#cb1-39" aria-hidden="true" tabindex="-1"></a>M <span class="op">+=</span> <span class="fu">transpose</span>(R3) <span class="op">*</span> <span class="fu">inv</span>(<span class="fu">R3*A*transpose</span>(R3)) <span class="op">*</span> R3;</span>
<span id="cb1-40"><a href="#cb1-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-41"><a href="#cb1-41" aria-hidden="true" tabindex="-1"></a><span class="im">using</span> <span class="bu">LinearAlgebra</span>: norm</span>
<span id="cb1-42"><a href="#cb1-42" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> iter <span class="kw">in</span> <span class="fl">1</span><span class="op">:</span><span class="fl">50</span></span>
<span id="cb1-43"><a href="#cb1-43" aria-hidden="true" tabindex="-1"></a>    dU <span class="op">=</span> M <span class="op">*</span> (F<span class="op">-</span>A<span class="op">*</span>U)</span>
<span id="cb1-44"><a href="#cb1-44" aria-hidden="true" tabindex="-1"></a>    <span class="kw">global</span> U <span class="op">+=</span> dU</span>
<span id="cb1-45"><a href="#cb1-45" aria-hidden="true" tabindex="-1"></a>    <span class="fu">println</span>(<span class="fu">norm</span>(dU))</span>
<span id="cb1-46"><a href="#cb1-46" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span>
<span id="cb1-47"><a href="#cb1-47" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-48"><a href="#cb1-48" aria-hidden="true" tabindex="-1"></a>exact <span class="op">=</span> A <span class="op">\</span> F;   <span class="co"># Julia's left division, i.e. A^{-1}*F</span></span>
<span id="cb1-49"><a href="#cb1-49" aria-hidden="true" tabindex="-1"></a><span class="im">using</span> <span class="bu">Plots</span></span>
<span id="cb1-50"><a href="#cb1-50" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(<span class="fl">1</span><span class="op">:</span>m, exact, label <span class="op">=</span> <span class="st">"exact"</span>)</span>
<span id="cb1-51"><a href="#cb1-51" aria-hidden="true" tabindex="-1"></a><span class="fu">plot!</span>(<span class="fl">1</span><span class="op">:</span>m, U, label<span class="op">=</span><span class="st">"approximate"</span>)   <span class="co"># overplot</span></span>
<span id="cb1-52"><a href="#cb1-52" aria-hidden="true" tabindex="-1"></a><span class="fu">savefig</span>(<span class="st">"serial.png"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="serial-additive-schwarz-method-with-structures" class="level3">
<h3 class="anchored" data-anchor-id="serial-additive-schwarz-method-with-structures">Serial additive Schwarz method with structures</h3>
<p>We will generalize our code to an arbitrary number of domains. Instead of using R1, R2, R3, we will define a structure <code>domainType</code> that will contain the restriction operator for each domain. It could contain other variables and matrices, but for now we don’t need any other elements in it.</p>
<p>Similar to the previous version of the code, here we are still storing all sparse and Boolean matrices as dense matrices, which is Ok only for testing purposes (for real problems these matrices will be large).</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode jl code-with-copy"><code class="sourceCode julia"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>m <span class="op">=</span> <span class="fl">21</span>               <span class="co"># total number of points</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>N <span class="op">=</span> <span class="fl">3</span>                <span class="co"># number of domains</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>ms <span class="op">=</span> <span class="fu">zeros</span>(<span class="dt">Int</span>, N)   <span class="co"># number of points in each domain</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>ms[<span class="fl">1</span><span class="op">:</span><span class="fl">2</span>] <span class="op">=</span> [<span class="fl">7</span>,<span class="fl">7</span>]      <span class="co"># number of points in the first two domains, respectively</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>ms[<span class="fl">3</span>] <span class="op">=</span> m <span class="op">-</span> <span class="fu">sum</span>(ms)</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>h <span class="op">=</span> <span class="fl">1.0</span> <span class="op">/</span> (m<span class="op">-</span><span class="fl">1</span>)      <span class="co"># grid spacing</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>U <span class="op">=</span> <span class="fu">zeros</span>(<span class="dt">Float64</span>, m, <span class="fl">1</span>);   <span class="co"># 0th iteration; will be a distributed 2D array</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>F <span class="op">=</span> <span class="fu">zeros</span>(<span class="dt">Float64</span>, m, <span class="fl">1</span>);   <span class="co"># RHS; will be a distributed 2D array</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>F[<span class="fu">trunc</span>(<span class="dt">Int</span>,m<span class="op">/</span><span class="fl">2</span>)<span class="op">-</span><span class="fl">3</span><span class="op">:</span><span class="fu">trunc</span>(<span class="dt">Int</span>,m<span class="op">/</span><span class="fl">2</span>)<span class="op">+</span><span class="fl">3</span>] <span class="op">.=</span> h<span class="op">^</span><span class="fl">2</span> <span class="op">*</span> <span class="fl">1.0</span>;</span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>A <span class="op">=</span> <span class="fu">zeros</span>(<span class="dt">Float64</span>, m, m);</span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>A[<span class="fl">1</span>,<span class="fl">1</span>], A[m,m] <span class="op">=</span> <span class="fl">1</span>, <span class="fl">1</span></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="fl">2</span><span class="op">:</span>m<span class="op">-</span><span class="fl">1</span></span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a>    A[i, i<span class="op">-</span><span class="fl">1</span>] <span class="op">=</span> <span class="op">-</span><span class="fl">1</span></span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a>    A[i,i] <span class="op">=</span> <span class="fl">2</span></span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a>    A[i, i<span class="op">+</span><span class="fl">1</span>] <span class="op">=</span> <span class="op">-</span><span class="fl">1</span></span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> domainType</span>
<span id="cb2-22"><a href="#cb2-22" aria-hidden="true" tabindex="-1"></a>    R<span class="op">::</span><span class="dt">Array{Int32}</span></span>
<span id="cb2-23"><a href="#cb2-23" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span>
<span id="cb2-24"><a href="#cb2-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-25"><a href="#cb2-25" aria-hidden="true" tabindex="-1"></a>domain <span class="op">=</span> <span class="fu">Array</span><span class="dt">{domainType, 1}</span>(<span class="cn">undef</span>, <span class="fl">3</span>)   <span class="co"># 3-element 1D array of domains</span></span>
<span id="cb2-26"><a href="#cb2-26" aria-hidden="true" tabindex="-1"></a>M <span class="op">=</span> <span class="fu">zeros</span>(<span class="dt">Float64</span>, m, m);</span>
<span id="cb2-27"><a href="#cb2-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-28"><a href="#cb2-28" aria-hidden="true" tabindex="-1"></a>offset <span class="op">=</span> [<span class="fl">0</span>, ms[<span class="fl">1</span>], ms[<span class="fl">1</span>]<span class="op">+</span>ms[<span class="fl">2</span>]];</span>
<span id="cb2-29"><a href="#cb2-29" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="fl">1</span><span class="op">:</span><span class="fl">3</span></span>
<span id="cb2-30"><a href="#cb2-30" aria-hidden="true" tabindex="-1"></a>    domain[i] <span class="op">=</span> <span class="fu">domainType</span>(<span class="fu">zeros</span>(<span class="dt">Int32</span>, ms[i], m)) <span class="co"># construct a new object of domainType</span></span>
<span id="cb2-31"><a href="#cb2-31" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> j <span class="kw">in</span> <span class="fl">1</span><span class="op">:</span>ms[i]</span>
<span id="cb2-32"><a href="#cb2-32" aria-hidden="true" tabindex="-1"></a>        domain[i].R[j,offset[i]<span class="op">+</span>j] <span class="op">=</span> <span class="fl">1</span></span>
<span id="cb2-33"><a href="#cb2-33" aria-hidden="true" tabindex="-1"></a>    <span class="cf">end</span></span>
<span id="cb2-34"><a href="#cb2-34" aria-hidden="true" tabindex="-1"></a>    <span class="kw">global</span> M <span class="op">+=</span> <span class="fu">transpose</span>(domain[i].R) <span class="op">*</span> <span class="fu">inv</span>(domain[i].<span class="fu">R*A*transpose</span>(domain[i].R)) <span class="op">*</span> domain[i].R;</span>
<span id="cb2-35"><a href="#cb2-35" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span>
<span id="cb2-36"><a href="#cb2-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-37"><a href="#cb2-37" aria-hidden="true" tabindex="-1"></a><span class="im">using</span> <span class="bu">LinearAlgebra</span>: norm</span>
<span id="cb2-38"><a href="#cb2-38" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> iter <span class="kw">in</span> <span class="fl">1</span><span class="op">:</span><span class="fl">50</span></span>
<span id="cb2-39"><a href="#cb2-39" aria-hidden="true" tabindex="-1"></a>    dU <span class="op">=</span> M <span class="op">*</span> (F<span class="op">-</span>A<span class="op">*</span>U)</span>
<span id="cb2-40"><a href="#cb2-40" aria-hidden="true" tabindex="-1"></a>    <span class="kw">global</span> U <span class="op">+=</span> dU</span>
<span id="cb2-41"><a href="#cb2-41" aria-hidden="true" tabindex="-1"></a>    <span class="fu">println</span>(<span class="fu">norm</span>(dU))</span>
<span id="cb2-42"><a href="#cb2-42" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span>
<span id="cb2-43"><a href="#cb2-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-44"><a href="#cb2-44" aria-hidden="true" tabindex="-1"></a>exact <span class="op">=</span> A <span class="op">\</span> F;</span>
<span id="cb2-45"><a href="#cb2-45" aria-hidden="true" tabindex="-1"></a><span class="im">using</span> <span class="bu">Plots</span></span>
<span id="cb2-46"><a href="#cb2-46" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(<span class="fl">1</span><span class="op">:</span>m, exact, label <span class="op">=</span> <span class="st">"exact"</span>)</span>
<span id="cb2-47"><a href="#cb2-47" aria-hidden="true" tabindex="-1"></a><span class="fu">plot!</span>(<span class="fl">1</span><span class="op">:</span>m, U, label<span class="op">=</span><span class="st">"approximate"</span>)</span>
<span id="cb2-48"><a href="#cb2-48" aria-hidden="true" tabindex="-1"></a><span class="fu">savefig</span>(<span class="st">"serial.png"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="parallel-additive-schwarz-method" class="level3">
<h3 class="anchored" data-anchor-id="parallel-additive-schwarz-method">Parallel additive Schwarz method</h3>
<!-- # complications: DArray of struct seems not possible in Julia, DArray of unbalanced partitions seems not possible in -->
<!-- # Julia (local DArray blocks must all have the same size), A*U does not work right now in Julia if U is distributed -->
<p>Imagine that now we are dealing with a very large problem, and we are breaking it into pieces, with each piece being processed by one worker. Now <span class="math inline">\(U\)</span> and <span class="math inline">\(F\)</span> will be 1D distributed arrays split between workers; we’ll implement them with distributed arrays.</p>
<p>Ideally, we would like to partition <code>domain</code> into subdomains with DistributedArrays.jl, and then on each processor use a combination of sparse and Boolean (coded explicitly with indices) matrices to solve the problem. However, at this point DistributedArrays.jl <strong>does not seem to support distributed arrays of structures</strong>.</p>
<p>At the heart of our implementation is the distributed preconditioner matrix <code>pre</code>. DistributedArrays.jl <strong>does not seem to support an uneven distribution of an array across processes</strong>, and therefore we are limited to having an equal number of points in all subdomains.</p>
<p><span class="math inline">\(A\)</span> is a sparse matrix. While Julia supports sparse matrices, instead we will code it algebraically with indices, so that we don’t have to worry about its distribution among processes.</p>
<p><span class="math inline">\(R_i\)</span> is Boolean. The matrix <span class="math inline">\(R_iAR_i^T\)</span> applies the domain restriction operator <span class="math inline">\(R_i\)</span> to both rows and columns of <span class="math inline">\(A\)</span>, and the result is coded algebraically with the function <code>fillPre()</code>. It is then inverted locally in each process with <code>invertPre()</code>.</p>
<p><span class="math inline">\(R_i^T\left(R_iAR_i^T\right)^{-1}R_i\)</span> takes the result of this inversion and puts it as a dense block into the <span class="math inline">\(m\times m\)</span> ASM preconditioner <span class="math inline">\(M^{-1}_\textrm{ASM}\)</span>. Each process computes its own dense block and stores it locally inside the distributed preconditioner matrix <code>pre</code>.</p>
<p>Next, we start iterations. In <code>computeUpdate()</code> we compute <span class="math inline">\(F-AU^n\)</span> as a 1D distributed array <code>tmp</code>, and multiply the preconditioner <code>pre</code> by <code>tmp</code>. Since <code>pre</code> is block-diagonal, this multiplication can be done separately in each process. Finally, we call <code>addUpdate()</code> to update the distributed solution <code>U</code>, again separately in each process.</p>
<p><strong>Big assumptions</strong>:</p>
<ol type="1">
<li>All distributed arrays are partitioned in exactly the same way, i.e.&nbsp;the same range of indices is assigned to each worker for 1D arrays <code>U</code>, <code>tmp</code>, <code>dU</code>, <code>F</code>.</li>
<li>The 2D array <code>pre</code> is partitioned purely along the second dimension (columns), i.e.&nbsp;each worker gets an <span class="math inline">\(m_s\times m_s\)</span> array, and the range of column indices on each worker is exactly the same as for the 1D arrays above.</li>
</ol>
<p>You can force (2) by replacing the line</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode jl code-with-copy"><code class="sourceCode julia"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>pre <span class="op">=</span> <span class="fu">dzeros</span>(<span class="dt">Float64</span>, ms, m);</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>with the following block</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode jl code-with-copy"><code class="sourceCode julia"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>d1 <span class="op">=</span> <span class="pp">@spawnat</span> <span class="fl">2</span> <span class="fu">zeros</span>(<span class="dt">Float64</span>, ms, ms);</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>d2 <span class="op">=</span> <span class="pp">@spawnat</span> <span class="fl">3</span> <span class="fu">zeros</span>(<span class="dt">Float64</span>, ms, ms);</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>d3 <span class="op">=</span> <span class="pp">@spawnat</span> <span class="fl">4</span> <span class="fu">zeros</span>(<span class="dt">Float64</span>, ms, ms);</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>pre <span class="op">=</span> <span class="fu">DArray</span>([d1 d2 d3]);</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Here is the entire parallel code:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode jl code-with-copy"><code class="sourceCode julia"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>N <span class="op">=</span> <span class="fl">3</span>    <span class="co"># number of domains and processes</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>m <span class="op">=</span> <span class="fl">21</span>   <span class="co"># total number of points; must be a multiple of N</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span class="pp">@assert</span> m<span class="op">%</span>N <span class="op">==</span> <span class="fl">0</span> <span class="st">"m must be a multiple of N"</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>ms <span class="op">=</span> <span class="fu">round</span>(<span class="dt">Int</span>, m<span class="op">/</span>N)   <span class="co"># the size of each subdomain</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>h <span class="op">=</span> <span class="fl">1.0</span> <span class="op">/</span> (m<span class="op">-</span><span class="fl">1</span>)        <span class="co"># grid spacing</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a><span class="im">using</span> <span class="bu">Distributed</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a><span class="fu">addprocs</span>(N)</span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a><span class="pp">@everywhere</span> <span class="im">using</span> <span class="bu">DistributedArrays</span></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>U <span class="op">=</span> <span class="fu">dzeros</span>(<span class="dt">Float64</span>, m, <span class="fl">1</span>);     <span class="co"># 0th iteration; a distributed 2D array</span></span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a>tmp <span class="op">=</span> <span class="fu">dzeros</span>(<span class="dt">Float64</span>, m, <span class="fl">1</span>);   <span class="co"># work area array</span></span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a>dU <span class="op">=</span> <span class="fu">dzeros</span>(<span class="dt">Float64</span>, m, <span class="fl">1</span>);    <span class="co"># update array</span></span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a>F <span class="op">=</span> <span class="fu">dzeros</span>(<span class="dt">Float64</span>, m, <span class="fl">1</span>);   <span class="co"># RHS; a distributed 2D array</span></span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a><span class="pp">@everywhere</span> <span class="kw">function</span> <span class="fu">fillF</span>(data,m,h)</span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a>    rows <span class="op">=</span> <span class="fu">localindices</span>(data)[<span class="fl">1</span>]</span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> iGlobal <span class="kw">in</span> rows</span>
<span id="cb5-19"><a href="#cb5-19" aria-hidden="true" tabindex="-1"></a>        iLoc <span class="op">=</span> iGlobal <span class="op">-</span> rows.start <span class="op">+</span> <span class="fl">1</span></span>
<span id="cb5-20"><a href="#cb5-20" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> iGlobal <span class="op">&gt;=</span> <span class="fu">trunc</span>(<span class="dt">Int</span>,m<span class="op">/</span><span class="fl">2</span>)<span class="op">-</span><span class="fl">3</span> <span class="op">&amp;&amp;</span> iGlobal <span class="op">&lt;=</span> <span class="fu">trunc</span>(<span class="dt">Int</span>,m<span class="op">/</span><span class="fl">2</span>)<span class="op">+</span><span class="fl">3</span></span>
<span id="cb5-21"><a href="#cb5-21" aria-hidden="true" tabindex="-1"></a>            data.localpart[iLoc] <span class="op">=</span> h<span class="op">^</span><span class="fl">2</span> <span class="op">*</span> <span class="fl">1.0</span>;</span>
<span id="cb5-22"><a href="#cb5-22" aria-hidden="true" tabindex="-1"></a>        <span class="cf">end</span></span>
<span id="cb5-23"><a href="#cb5-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">end</span></span>
<span id="cb5-24"><a href="#cb5-24" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span>
<span id="cb5-25"><a href="#cb5-25" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> w <span class="kw">in</span> <span class="fu">workers</span>()</span>
<span id="cb5-26"><a href="#cb5-26" aria-hidden="true" tabindex="-1"></a>    <span class="pp">@spawnat</span> w <span class="fu">fillF</span>(F, m, h)</span>
<span id="cb5-27"><a href="#cb5-27" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span>
<span id="cb5-28"><a href="#cb5-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-29"><a href="#cb5-29" aria-hidden="true" tabindex="-1"></a>pre <span class="op">=</span> <span class="fu">dzeros</span>(<span class="dt">Float64</span>, ms, m);</span>
<span id="cb5-30"><a href="#cb5-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-31"><a href="#cb5-31" aria-hidden="true" tabindex="-1"></a><span class="pp">@everywhere</span> <span class="kw">function</span> <span class="fu">fillPre</span>(data, rank, ms, N)</span>
<span id="cb5-32"><a href="#cb5-32" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> rank <span class="op">==</span> <span class="fl">1</span></span>
<span id="cb5-33"><a href="#cb5-33" aria-hidden="true" tabindex="-1"></a>        data.localpart[<span class="fl">1</span>,<span class="fl">1</span>] <span class="op">=</span> <span class="fl">1</span></span>
<span id="cb5-34"><a href="#cb5-34" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> iLoc <span class="kw">in</span> <span class="fl">2</span><span class="op">:</span>ms   <span class="co"># main diagonal</span></span>
<span id="cb5-35"><a href="#cb5-35" aria-hidden="true" tabindex="-1"></a>            data.localpart[iLoc,iLoc] <span class="op">=</span> <span class="fl">2</span></span>
<span id="cb5-36"><a href="#cb5-36" aria-hidden="true" tabindex="-1"></a>        <span class="cf">end</span></span>
<span id="cb5-37"><a href="#cb5-37" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> iLoc <span class="kw">in</span> <span class="fl">3</span><span class="op">:</span>ms   <span class="co"># above main diagonal</span></span>
<span id="cb5-38"><a href="#cb5-38" aria-hidden="true" tabindex="-1"></a>            data.localpart[iLoc<span class="op">-</span><span class="fl">1</span>,iLoc] <span class="op">=</span> <span class="op">-</span><span class="fl">1</span></span>
<span id="cb5-39"><a href="#cb5-39" aria-hidden="true" tabindex="-1"></a>        <span class="cf">end</span></span>
<span id="cb5-40"><a href="#cb5-40" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> iLoc <span class="kw">in</span> <span class="fl">1</span><span class="op">:</span>ms<span class="op">-</span><span class="fl">1</span>   <span class="co"># below main diagonal</span></span>
<span id="cb5-41"><a href="#cb5-41" aria-hidden="true" tabindex="-1"></a>            data.localpart[iLoc<span class="op">+</span><span class="fl">1</span>,iLoc] <span class="op">=</span> <span class="op">-</span><span class="fl">1</span></span>
<span id="cb5-42"><a href="#cb5-42" aria-hidden="true" tabindex="-1"></a>        <span class="cf">end</span></span>
<span id="cb5-43"><a href="#cb5-43" aria-hidden="true" tabindex="-1"></a>    <span class="cf">end</span></span>
<span id="cb5-44"><a href="#cb5-44" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> rank <span class="op">&gt;</span> <span class="fl">1</span> <span class="op">&amp;&amp;</span> rank <span class="op">&lt;</span> N</span>
<span id="cb5-45"><a href="#cb5-45" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> iLoc <span class="kw">in</span> <span class="fl">1</span><span class="op">:</span>ms   <span class="co"># main diagonal</span></span>
<span id="cb5-46"><a href="#cb5-46" aria-hidden="true" tabindex="-1"></a>            data.localpart[iLoc,iLoc] <span class="op">=</span> <span class="fl">2</span></span>
<span id="cb5-47"><a href="#cb5-47" aria-hidden="true" tabindex="-1"></a>        <span class="cf">end</span></span>
<span id="cb5-48"><a href="#cb5-48" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> iLoc <span class="kw">in</span> <span class="fl">2</span><span class="op">:</span>ms   <span class="co"># above main diagonal</span></span>
<span id="cb5-49"><a href="#cb5-49" aria-hidden="true" tabindex="-1"></a>            data.localpart[iLoc<span class="op">-</span><span class="fl">1</span>,iLoc] <span class="op">=</span> <span class="op">-</span><span class="fl">1</span></span>
<span id="cb5-50"><a href="#cb5-50" aria-hidden="true" tabindex="-1"></a>        <span class="cf">end</span></span>
<span id="cb5-51"><a href="#cb5-51" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> iLoc <span class="kw">in</span> <span class="fl">1</span><span class="op">:</span>ms<span class="op">-</span><span class="fl">1</span>   <span class="co"># below main diagonal</span></span>
<span id="cb5-52"><a href="#cb5-52" aria-hidden="true" tabindex="-1"></a>            data.localpart[iLoc<span class="op">+</span><span class="fl">1</span>,iLoc] <span class="op">=</span> <span class="op">-</span><span class="fl">1</span></span>
<span id="cb5-53"><a href="#cb5-53" aria-hidden="true" tabindex="-1"></a>        <span class="cf">end</span></span>
<span id="cb5-54"><a href="#cb5-54" aria-hidden="true" tabindex="-1"></a>    <span class="cf">end</span></span>
<span id="cb5-55"><a href="#cb5-55" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> rank <span class="op">==</span> N</span>
<span id="cb5-56"><a href="#cb5-56" aria-hidden="true" tabindex="-1"></a>        data.localpart[ms,ms] <span class="op">=</span> <span class="fl">1</span></span>
<span id="cb5-57"><a href="#cb5-57" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> iLoc <span class="kw">in</span> <span class="fl">1</span><span class="op">:</span>ms<span class="op">-</span><span class="fl">1</span>   <span class="co"># main diagonal</span></span>
<span id="cb5-58"><a href="#cb5-58" aria-hidden="true" tabindex="-1"></a>            data.localpart[iLoc,iLoc] <span class="op">=</span> <span class="fl">2</span></span>
<span id="cb5-59"><a href="#cb5-59" aria-hidden="true" tabindex="-1"></a>        <span class="cf">end</span></span>
<span id="cb5-60"><a href="#cb5-60" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> iLoc <span class="kw">in</span> <span class="fl">2</span><span class="op">:</span>ms   <span class="co"># above main diagonal</span></span>
<span id="cb5-61"><a href="#cb5-61" aria-hidden="true" tabindex="-1"></a>            data.localpart[iLoc<span class="op">-</span><span class="fl">1</span>,iLoc] <span class="op">=</span> <span class="op">-</span><span class="fl">1</span></span>
<span id="cb5-62"><a href="#cb5-62" aria-hidden="true" tabindex="-1"></a>        <span class="cf">end</span></span>
<span id="cb5-63"><a href="#cb5-63" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> iLoc <span class="kw">in</span> <span class="fl">1</span><span class="op">:</span>ms<span class="op">-</span><span class="fl">2</span>   <span class="co"># below main diagonal</span></span>
<span id="cb5-64"><a href="#cb5-64" aria-hidden="true" tabindex="-1"></a>            data.localpart[iLoc<span class="op">+</span><span class="fl">1</span>,iLoc] <span class="op">=</span> <span class="op">-</span><span class="fl">1</span></span>
<span id="cb5-65"><a href="#cb5-65" aria-hidden="true" tabindex="-1"></a>        <span class="cf">end</span></span>
<span id="cb5-66"><a href="#cb5-66" aria-hidden="true" tabindex="-1"></a>    <span class="cf">end</span></span>
<span id="cb5-67"><a href="#cb5-67" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span>
<span id="cb5-68"><a href="#cb5-68" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> (rank,w) <span class="kw">in</span> <span class="fu">enumerate</span>(<span class="fu">workers</span>())</span>
<span id="cb5-69"><a href="#cb5-69" aria-hidden="true" tabindex="-1"></a>    <span class="pp">@spawnat</span> w <span class="fu">fillPre</span>(pre, rank, ms, N)</span>
<span id="cb5-70"><a href="#cb5-70" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span>
<span id="cb5-71"><a href="#cb5-71" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-72"><a href="#cb5-72" aria-hidden="true" tabindex="-1"></a><span class="pp">@everywhere</span> <span class="kw">function</span> <span class="fu">invertPre</span>(data)</span>
<span id="cb5-73"><a href="#cb5-73" aria-hidden="true" tabindex="-1"></a>    data.localpart <span class="op">=</span> <span class="fu">inv</span>(data.localpart)</span>
<span id="cb5-74"><a href="#cb5-74" aria-hidden="true" tabindex="-1"></a>    <span class="co"># println(data.localpart)</span></span>
<span id="cb5-75"><a href="#cb5-75" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span>
<span id="cb5-76"><a href="#cb5-76" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> w <span class="kw">in</span> <span class="fu">workers</span>()</span>
<span id="cb5-77"><a href="#cb5-77" aria-hidden="true" tabindex="-1"></a>    <span class="pp">@spawnat</span> w <span class="fu">invertPre</span>(pre)</span>
<span id="cb5-78"><a href="#cb5-78" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span>
<span id="cb5-79"><a href="#cb5-79" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-80"><a href="#cb5-80" aria-hidden="true" tabindex="-1"></a><span class="pp">@everywhere</span> <span class="kw">function</span> <span class="fu">computeUpdate</span>(data, F, U, ms, rank, N, tmp, dU)</span>
<span id="cb5-81"><a href="#cb5-81" aria-hidden="true" tabindex="-1"></a>    <span class="co"># (1) compute tmp = (F-A*U)</span></span>
<span id="cb5-82"><a href="#cb5-82" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> rank <span class="op">==</span> <span class="fl">1</span></span>
<span id="cb5-83"><a href="#cb5-83" aria-hidden="true" tabindex="-1"></a>        tmp.localpart[<span class="fl">1</span>] <span class="op">=</span> F.localpart[<span class="fl">1</span>] <span class="op">-</span> U[<span class="fl">1</span>]</span>
<span id="cb5-84"><a href="#cb5-84" aria-hidden="true" tabindex="-1"></a>        <span class="co"># for rank==1 we always have iGlobal = iLoc</span></span>
<span id="cb5-85"><a href="#cb5-85" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> iLoc <span class="kw">in</span> <span class="fl">2</span><span class="op">:</span>ms</span>
<span id="cb5-86"><a href="#cb5-86" aria-hidden="true" tabindex="-1"></a>            tmp.localpart[iLoc] <span class="op">=</span> F.localpart[iLoc] <span class="op">+</span> U[iLoc<span class="op">-</span><span class="fl">1</span>] <span class="op">-</span> <span class="fl">2</span><span class="op">*</span>U[iLoc] <span class="op">+</span> U[iLoc<span class="op">+</span><span class="fl">1</span>] <span class="co"># last one has U[ms+1] =&gt; domains communicate</span></span>
<span id="cb5-87"><a href="#cb5-87" aria-hidden="true" tabindex="-1"></a>        <span class="cf">end</span></span>
<span id="cb5-88"><a href="#cb5-88" aria-hidden="true" tabindex="-1"></a>    <span class="cf">end</span></span>
<span id="cb5-89"><a href="#cb5-89" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> rank <span class="op">&gt;</span> <span class="fl">1</span> <span class="op">&amp;&amp;</span> rank <span class="op">&lt;</span> N</span>
<span id="cb5-90"><a href="#cb5-90" aria-hidden="true" tabindex="-1"></a>        iGlobal <span class="op">=</span> (rank<span class="op">-</span><span class="fl">1</span>)<span class="op">*</span>ms</span>
<span id="cb5-91"><a href="#cb5-91" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> iLoc <span class="kw">in</span> <span class="fl">1</span><span class="op">:</span>ms</span>
<span id="cb5-92"><a href="#cb5-92" aria-hidden="true" tabindex="-1"></a>            iGlobal <span class="op">+=</span> <span class="fl">1</span></span>
<span id="cb5-93"><a href="#cb5-93" aria-hidden="true" tabindex="-1"></a>            tmp.localpart[iLoc] <span class="op">=</span> F.localpart[iLoc] <span class="op">+</span> U[iGlobal<span class="op">-</span><span class="fl">1</span>] <span class="op">-</span> <span class="fl">2</span><span class="op">*</span>U[iGlobal] <span class="op">+</span> U[iGlobal<span class="op">+</span><span class="fl">1</span>]</span>
<span id="cb5-94"><a href="#cb5-94" aria-hidden="true" tabindex="-1"></a>        <span class="cf">end</span></span>
<span id="cb5-95"><a href="#cb5-95" aria-hidden="true" tabindex="-1"></a>    <span class="cf">end</span></span>
<span id="cb5-96"><a href="#cb5-96" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> rank <span class="op">==</span> N</span>
<span id="cb5-97"><a href="#cb5-97" aria-hidden="true" tabindex="-1"></a>        iGlobal <span class="op">=</span> (rank<span class="op">-</span><span class="fl">1</span>)<span class="op">*</span>ms</span>
<span id="cb5-98"><a href="#cb5-98" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> iLoc <span class="kw">in</span> <span class="fl">1</span><span class="op">:</span>ms<span class="op">-</span><span class="fl">1</span></span>
<span id="cb5-99"><a href="#cb5-99" aria-hidden="true" tabindex="-1"></a>            iGlobal <span class="op">+=</span> <span class="fl">1</span></span>
<span id="cb5-100"><a href="#cb5-100" aria-hidden="true" tabindex="-1"></a>            tmp.localpart[iLoc] <span class="op">=</span> F.localpart[iLoc] <span class="op">+</span> U[iGlobal<span class="op">-</span><span class="fl">1</span>] <span class="op">-</span> <span class="fl">2</span><span class="op">*</span>U[iGlobal] <span class="op">+</span> U[iGlobal<span class="op">+</span><span class="fl">1</span>]</span>
<span id="cb5-101"><a href="#cb5-101" aria-hidden="true" tabindex="-1"></a>        <span class="cf">end</span></span>
<span id="cb5-102"><a href="#cb5-102" aria-hidden="true" tabindex="-1"></a>        tmp.localpart[ms] <span class="op">=</span> F.localpart[ms] <span class="op">-</span> U[rank<span class="op">*</span>ms]</span>
<span id="cb5-103"><a href="#cb5-103" aria-hidden="true" tabindex="-1"></a>    <span class="cf">end</span></span>
<span id="cb5-104"><a href="#cb5-104" aria-hidden="true" tabindex="-1"></a>    <span class="co"># (2) compute pre*tmp</span></span>
<span id="cb5-105"><a href="#cb5-105" aria-hidden="true" tabindex="-1"></a>    dU.localpart <span class="op">=</span> data.localpart<span class="op">*</span>tmp.localpart</span>
<span id="cb5-106"><a href="#cb5-106" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> rank <span class="op">==</span> <span class="fl">1</span></span>
<span id="cb5-107"><a href="#cb5-107" aria-hidden="true" tabindex="-1"></a>        <span class="fu">println</span>(<span class="fu">norm</span>(dU.localpart))</span>
<span id="cb5-108"><a href="#cb5-108" aria-hidden="true" tabindex="-1"></a>    <span class="cf">end</span></span>
<span id="cb5-109"><a href="#cb5-109" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span>
<span id="cb5-110"><a href="#cb5-110" aria-hidden="true" tabindex="-1"></a><span class="pp">@everywhere</span> <span class="kw">function</span> <span class="fu">addUpdate</span>(U, dU)</span>
<span id="cb5-111"><a href="#cb5-111" aria-hidden="true" tabindex="-1"></a>    U.localpart <span class="op">+=</span> dU.localpart</span>
<span id="cb5-112"><a href="#cb5-112" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span>
<span id="cb5-113"><a href="#cb5-113" aria-hidden="true" tabindex="-1"></a><span class="pp">@everywhere</span> <span class="im">using</span> <span class="bu">LinearAlgebra</span>: norm</span>
<span id="cb5-114"><a href="#cb5-114" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-115"><a href="#cb5-115" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> iter <span class="kw">in</span> <span class="fl">1</span><span class="op">:</span><span class="fl">50</span></span>
<span id="cb5-116"><a href="#cb5-116" aria-hidden="true" tabindex="-1"></a>    <span class="pp">@sync</span> <span class="cf">for</span> (rank,w) <span class="kw">in</span> <span class="fu">enumerate</span>(<span class="fu">workers</span>())</span>
<span id="cb5-117"><a href="#cb5-117" aria-hidden="true" tabindex="-1"></a>        <span class="pp">@spawnat</span> w <span class="fu">computeUpdate</span>(pre, F, U, ms, rank, N, tmp, dU)</span>
<span id="cb5-118"><a href="#cb5-118" aria-hidden="true" tabindex="-1"></a>    <span class="cf">end</span></span>
<span id="cb5-119"><a href="#cb5-119" aria-hidden="true" tabindex="-1"></a>    <span class="pp">@sync</span> <span class="cf">for</span> w <span class="kw">in</span> <span class="fu">workers</span>()</span>
<span id="cb5-120"><a href="#cb5-120" aria-hidden="true" tabindex="-1"></a>        <span class="pp">@spawnat</span> w <span class="fu">addUpdate</span>(U, dU)</span>
<span id="cb5-121"><a href="#cb5-121" aria-hidden="true" tabindex="-1"></a>    <span class="cf">end</span></span>
<span id="cb5-122"><a href="#cb5-122" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span>
<span id="cb5-123"><a href="#cb5-123" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-124"><a href="#cb5-124" aria-hidden="true" tabindex="-1"></a><span class="im">using</span> <span class="bu">Plots</span></span>
<span id="cb5-125"><a href="#cb5-125" aria-hidden="true" tabindex="-1"></a>Ulocal <span class="op">=</span> <span class="fu">zeros</span>(<span class="dt">Float64</span>, m, <span class="fl">1</span>);</span>
<span id="cb5-126"><a href="#cb5-126" aria-hidden="true" tabindex="-1"></a>Ulocal <span class="op">.=</span> U</span>
<span id="cb5-127"><a href="#cb5-127" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(<span class="fl">1</span><span class="op">:</span>m, Ulocal, label<span class="op">=</span><span class="st">"approximate"</span>)</span>
<span id="cb5-128"><a href="#cb5-128" aria-hidden="true" tabindex="-1"></a><span class="fu">savefig</span>(<span class="st">"parallel.png"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><code>Ulocal</code> is necessary since the <code>plot()</code> function <strong>won’t take the distributed array</strong> <code>U</code> as an argument.</p>
<!-- 1. pick a point $z_0\in\mathbb{C}$ -->
<!-- In this section I will describe one of the two projects you can work on this afternoon. The project is the mathematical -->
<!-- problem to compute **Julia set** -- no relation to Julia language! A -->
<!-- [Julia set](https://en.wikipedia.org/wiki/Julia_set) is defined as a set of points on the complex plane that remain -->
<!-- bound under infinite recursive transformation $f(z)$. We will use the traditional form $f(z)=z^2+c$, where $c$ is a -->
<!-- complex constant. Here is our algorithm: -->
<!-- 1. pick a point $z_0\in\mathbb{C}$ -->
<!-- 1. compute iterations $z_{i+1}=z_i^2+c$ until $|z_i|>4$ (arbitrary fixed radius; here $c$ is a complex constant) -->
<!-- 1. store the iteration number $\xi(z_0)$ at which $z_i$ reaches the circle $|z|=4$ -->
<!-- 1. limit max iterations at 255   -->

<!--     4.1 if $\xi(z_0)=255$, then $z_0$ is a stable point   -->
<!--     4.2 the quicker a point diverges, the lower its $\xi(z_0)$ is -->
<!-- 1. plot $\xi(z_0)$ for all $z_0$ in a rectangular region $-1<=\mathfrak{Re}(z_0)<=1$, $-1<=\mathfrak{Im}(z_0)<=1$ -->
<!-- We should get something conceptually similar to this figure (here $c = 0.355 + 0.355i$; we'll get drastically different -->
<!-- fractals for different values of $c$): -->
<!-- {{< figure src="/img/2000a.png" >}} -->
<!-- Below is the serial code `juliaSetSerial.jl`. First, you need to install the required packages: -->
<!-- ```julia -->
<!-- ] add ProgressMeter -->
<!-- ] add NetCDF -->
<!-- ``` -->
<!-- Next, let's study the code: -->
<!-- ```julia -->
<!-- using ProgressMeter, NetCDF -->
<!-- function pixel(i, j, width, height, c, zoomOut) -->
<!--     z = (2*(j-0.5)/width-1)+(2*(i-0.5)/height-1)im   # rescale to -1:1 in the complex plane -->
<!--     z *= zoomOut -->
<!--     for i = 1:255 -->
<!--         z = z^2 + c -->
<!--         if abs(z) >= 4 -->
<!--             return i -->
<!--         end -->
<!--     end -->
<!--     return 255 -->
<!-- end -->
<!-- n = Int(8e3)             # plot size -->
<!-- height, width = n, n -->
<!-- c, zoomOut = 0.355 + 0.355im, 1.2 -->
<!-- println("Computing Julia set ...") -->
<!-- data = zeros(Float32, height, width);   # local array -->
<!-- @showprogress for i in 1:height, j in 1:width -->
<!--     data[i,j] = pixel(i, j, width, height, c, zoomOut) -->
<!-- end -->
<!-- # println("Very slow plotting ...") -->
<!-- # using Plots -->
<!-- # gr()    # initialize the gr backend -->
<!-- # file_name = "$(height)x$(width)_$(c.re)_$(c.im)" -->
<!-- # png(heatmap(data, size=(width,height), color=:gist_ncar), file_name)   # save to PNG -->
<!-- # println("On-screen b/w plotting ... slow too") -->
<!-- # using ImageView -->
<!-- # imshow(data) -->
<!-- println("Writing NetCDF ...") -->
<!-- filename = "test.nc" -->
<!-- isfile(filename) && rm(filename)        # compact if statement -->
<!-- nccreate(filename, "stability", "x", collect(1:height), "y", -->
<!--          collect(1:width), t=NC_FLOAT, mode=NC_NETCDF4, compress=9); -->
<!-- ncwrite(data, filename, "stability"); -->
<!-- ``` -->
<!-- Let's run this code. It'll produce the file `test.nc` that you can download to your computer and visualize with ParaView -->
<!-- or other visualization tool. -->
<!-- > ### Exercise 11 -->
<!-- > 1. Compare the expected and actual file sizes. -->
<!-- > 1. Try other parameter values: -->
<!-- > ```julia -->
<!-- > c, zoomOut = 0.355 + 0.355im, 1.2   # the default one: spirals -->
<!-- > c, zoomOut = 1.2exp(1.1π*im), 1     # original textbook example -->
<!-- > c, zoomOut = -0.4 - 0.59im, 1.5     # denser spirals -->
<!-- > c, zoomOut = 1.34 - 0.45im, 1.8     # beans -->
<!-- > c, zoomOut = 0.34 -0.05im, 1.2      # connected spiral boots -->
<!-- > ``` -->
<!-- > 3. You can also try increasing problem sizes up from $8000^2$. Will you have enough physical memory for $16000^2$? -->
<!-- >    How does this affect the runtime? -->
<!-- ### Parallelizing -->
<!-- How would we parallelize this problem? We have a large array, so we can use DistributedArrays and compute it in -->
<!-- parallel. Here are the steps: -->
<!-- 1. Some functions (packages) should be defined (loaded) on all processes. -->
<!-- 1. `data` array should be distributed. -->
<!-- 1. You need `fillLocalBlock(data, width, height, c, zoomOut)` to compute local pieces of `data` in parallel. If you -->
<!--    don't know where to start in this project, begin with looking at the complete example with `fillLocalBlock()` from -->
<!--    the previous section. -->
<!-- 1. You can replace -->
<!-- ```julia -->
<!-- @showprogress for i in 1:height, j in 1:width -->
<!--     data[i,j] = pixel(i, j, width, height, c, zoomOut) -->
<!-- ``` -->
<!-- with -->
<!-- ```julia -->
<!-- data = dzeros(Float32, height, width);   # distributed 2D array of 0's -->
<!-- @time @sync for i in workers() -->
<!--     @spawnat i fillLocalBlock(data, width, height, c, zoomOut) -->
<!-- ``` -->
<!-- 5. Why do we need `@sync` in the previous `for` block? -->
<!-- 6. To the best of my knowledge, NetCDF's `ncwrite()` is serial in Julia. Is there a parallel version of NetCDF for -->
<!--    Julia? If not, then unfortunately we will have to use serial NetCDF. How do we do this with distributed `data`? -->
<!-- 7. Time only the `for` loop in computing the array. Is your parallel code faster? -->
<!-- ### Results -->
<!-- Finally, here are my timings on Uu: -->
<!-- | Code | Time  | -->
<!-- | ------------- | ----- | -->
<!-- | `julia juliaSetSerial.jl` (serial runtime) | 43.1s &nbsp;&nbsp;&nbsp; 41.4s &nbsp;&nbsp; 41.4s  | -->
<!-- | `julia -p 1 juliaSetDistributedArrays.jl` (on 1 worker) | 29.6s &nbsp;&nbsp; 29.6s &nbsp;&nbsp; 29.2s | -->
<!-- | `julia -p 2 juliaSetDistributedArrays.jl` (on 2 workers) | 15.4s &nbsp;&nbsp; 15.6s &nbsp;&nbsp; 15.2s | -->


</section>


</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    target: function(trigger) {
      return trigger.previousElementSibling;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var filterRegex = new RegExp(/https:\/\/2023uvic\.netlify\.app\//);
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
    var links = window.document.querySelectorAll('a:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
          // target, if specified
          link.setAttribute("target", "_blank");
      }
    }
});
</script>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
      <div class="nav-footer-center">
        <ul class="footer-items list-unstyled">
    <li class="nav-item">
    <a class="nav-link" href="../about.html">About</a>
  </li>  
    <li class="nav-item">
    <a class="nav-link" href="../calendar.html">Calendar</a>
  </li>  
    <li class="nav-item">
    <a class="nav-link" href="../newsletter.html">Newsletter</a>
  </li>  
    <li class="nav-item">
    <a class="nav-link" href="../contact.html">Contact</a>
  </li>  
    <li class="nav-item">
    <a class="nav-link" href="https://docs.alliancecan.ca/wiki/Technical_documentation">Wiki</a>
  </li>  
</ul>
      </div>
    <div class="nav-footer-right">
      <ul class="footer-items list-unstyled">
    <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/WestDRI">
      <i class="bi bi-github" role="img" aria-label="WestDRI GitHub">
</i> 
    </a>
  </li>  
    <li class="nav-item compact">
    <a class="nav-link" href="https://www.youtube.com/channel/UCfgds4Qf7VFOv4ORRvFFmhw">
      <i class="bi bi-youtube" role="img" aria-label="WestDRI YouTube">
</i> 
    </a>
  </li>  
</ul>
    </div>
  </div>
</footer>



</body></html>